# Screenshot Automation System - AI Development Context

## Overview
This directory contains a Puppeteer-based screenshot automation system designed to capture consistent screenshots of the Morse Code Trainer app across different environments and viewports. The system was built to solve the challenge of maintaining up-to-date documentation screenshots and enabling easy comparison between local development and live production versions.

## Architecture

### Core Files
- **`screenshot.js`** - Main automation script with consolidated functionality
- **`package.json`** - Node.js dependencies and npm scripts
- **`README.md`** - Human-readable documentation
- **`.vibe_coding.md`** - This AI context file

### Key Dependencies
- **Puppeteer v22.15.0** - Headless Chrome automation
- **Node.js built-ins** - fs, path for file operations

## Script Functionality

### Command Line Interface
The script supports four execution modes via command-line flags:
- `--local` - Screenshots from local development server (http://localhost:8000)
- `--live` - Screenshots from GitHub Pages production site
- `--both` - Comprehensive mode that captures both local and live versions
- Default (no flags) - Defaults to local mode

### Screenshot Scenarios
The system captures 6 distinct app states:
1. **Main Menu** (`01-main-menu`) - App landing page with navigation options
2. **Settings Modal** (`02-settings-modal`) - Configuration interface (with auto-close)
3. **Character to Morse** (`03-char-to-morse`) - First practice mode
4. **Morse to Character** (`04-morse-to-char`) - Second practice mode  
5. **Sound to Character** (`05-sound-to-char`) - Audio-based practice mode
6. **Learn Mode** (`06-learn-mode`) - Reference/study interface

### Viewport Configuration
- **Desktop**: 1200x800 pixels (standard desktop experience)
- **Mobile**: 375x667 pixels (iPhone-like mobile experience)

## Technical Implementation

### Navigation Strategy
The app uses hash-based routing with dynamic content loading. The script handles this by:
1. Navigating to specific hash URLs (e.g., `#char-to-morse`)
2. Waiting 2 seconds for dynamic content to load via fetch API
3. Using fresh browser pages for each screenshot to avoid state contamination

### Modal Handling
Settings modal requires special handling:
- Opens modal via click action (`#settings-btn`)
- Waits for modal to appear (`#settings-modal`)
- Takes screenshot
- Closes modal via click action (`#close-settings`) to prevent interference

### Screenshot Configuration
All screenshots use `fullPage: false` to capture only the visible viewport, ensuring:
- Consistent image dimensions
- Realistic user experience representation
- Optimal file sizes for documentation

### Output Organization
Screenshots are organized in a hierarchical structure:
```
_screenshots/
├── local/              # Local development screenshots
│   ├── desktop/        # Desktop viewport screenshots
│   └── mobile/         # Mobile viewport screenshots
└── live/               # Production site screenshots
    ├── desktop/        # Desktop viewport screenshots
    └── mobile/         # Mobile viewport screenshots
```

## Development Patterns

### Browser Security Configuration
The script launches Puppeteer with default security settings (sandbox enabled) for maximum security. In some restricted environments (Docker containers, CI/CD systems), you may encounter sandbox-related errors. If this occurs, you can add the following args as a last resort:

```javascript
args: ['--no-sandbox', '--disable-setuid-sandbox']
```

However, this reduces security isolation and should only be used when:
1. Running in a controlled environment
2. Only accessing trusted content (your own app)
3. Proper sandboxing configuration is not feasible

For production deployments, consider:
- Using Docker with proper capabilities (`--cap-add=SYS_ADMIN`)
- Configuring proper user permissions
- Using container orchestration with security policies

### Error Handling
- Individual screenshot failures don't stop the entire process
- Clear console logging for debugging
- Graceful degradation with meaningful error messages

### Performance Optimizations
- Fresh browser page for each screenshot prevents state leakage
- Minimal wait times (2 seconds) based on app performance characteristics
- Headless browser execution for speed

### Timing Considerations
The 2-second delay was determined through debugging and matches the app's dynamic loading patterns:
- Hash navigation triggers JavaScript module loading
- Content is fetched from HTML files and injected into DOM
- Initialization functions run after content loading

## Integration with Main App

### App Architecture Compatibility
The screenshot system is designed around the app's specific architecture:
- **ES6 modules** with dynamic imports
- **Hash-based routing** with history API
- **Dynamic HTML loading** via fetch
- **Cookie-based settings** persistence

### Selector Strategy
Uses stable selectors that match the app's HTML structure:
- `.menu-btn` for main menu detection
- `#settings-modal` for modal state
- `#game-container` for practice mode content

## Usage Patterns

### Development Workflow
1. **Local testing**: `npm run screenshot-local` during development
2. **Production validation**: `npm run screenshot-live` after deployment
3. **Comparison analysis**: `npm run screenshot-both` for comprehensive testing

### Documentation Integration
Screenshots automatically populate the main README.md file:
- Mobile screenshots used for compact presentation
- Single-row layout showing app progression
- Consistent viewport sizing for professional appearance

## Maintenance Considerations

### When to Update Screenshots
- After UI/UX changes
- Before major releases
- When adding new features
- For documentation updates

### Common Debugging Steps
1. Verify local server is running (`python3 -m http.server`)
2. Check console output for specific error messages
3. Validate selectors match current HTML structure
4. Adjust timing if dynamic loading changes

### Extension Points
The system can be easily extended by:
- Adding new scenarios to the `scenarios` array
- Modifying viewport sizes in the config
- Adding new command-line flags
- Implementing additional screenshot formats

## GitHub Pages Integration

### Deployment Considerations
- `_scripts/` directory is ignored by GitHub Pages (underscore prefix)
- Screenshots saved to `_screenshots/` are also ignored by GitHub Pages
- Live URL configuration needs manual update for different domains

### Automation Potential
The system is designed to be CI/CD friendly and could be integrated into:
- GitHub Actions workflows
- Pre-commit hooks
- Automated testing pipelines
- Release processes

## Performance Characteristics

### Execution Time
- Single mode (local or live): ~30-45 seconds
- Both mode: ~60-90 seconds
- Depends on network latency for live screenshots

### Resource Usage
- Minimal disk space (screenshots ~40-60KB each)
- Low memory footprint (headless browser)
- Network dependent for live mode

This screenshot system represents a mature solution for maintaining visual documentation of a dynamic web application, with careful consideration for both developer experience and end-user presentation.
